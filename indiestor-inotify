#!/usr/bin/php
<?php

/*
        Indiestor program
        Concept, requirements, specifications, and unit testing
        By Alex Gardiner, alex@indiestor.com
        Written by Erik Poupaert, erik@sankuru.biz
        Commissioned at peopleperhour.com 
        Licensed under the GPL
*/

//--------------------------
//Check deployment location
//--------------------------
if (dirname(__FILE__)=='/usr/share/indiestor/prg')
{
	$BIN='/usr/bin';
	$LIB='/usr/share/indiestor';
	$INUSER='indienotify';
}
else
{
	$BIN=dirname(__FILE__);
	$LIB=dirname(__FILE__).'/lib';
	$INUSER='root';
}

function indiestor_INUSER()
{
	global $INUSER;
	return $INUSER;
}

function indiestor_BIN()
{
	global $BIN;
	return $BIN;
}

function requireLibFile($path)
{
	global $LIB;
	require_once("$LIB/$path");
}

//--------------------------
// CHMOD RECURSIVE
//--------------------------

function chmodBase($path,$mode,$userName,$groupName)
{
        $currentMode=fileperms($path) & 0777;
        if($currentMode!=$mode)
        {
                chmod($path, $mode);
                $currentModeOct=decoct($currentMode);
                $modeOct=decoct($mode);
                syslog_notice("chmodBase-permissions: $path: $currentModeOct => $modeOct");
        }
        //check ownership
        if($mode==0775 || $mode==0664 )
        {
                $userRecord=posix_getpwuid(fileowner($path));
                $currentOwner=$userRecord['name'];
                if($currentOwner!=$userName)
                {
                        chown($path,$userName);
                        syslog_notice("chmodBase-owner: $path: $currentOwner => $userName");
                }
                $groupRecord=posix_getgrgid(filegroup($path));
                $currentGroup=$groupRecord['name'];
                if($currentGroup!=$groupName)
                {
                        chgrp($path,$groupName);
                        syslog_notice("chmodBase-group: $path: $currentGroup => $groupName");
                }
        }
}

function chmodRecursive($path, $modeFile,$modeFolder,$userName,$groupName) 
{ 
        if (is_dir($path)) 
        {
                chmodBase($path,$modeFolder,$userName,$groupName);
                $dh = opendir($path); 
                while (($file = readdir($dh)) !== false) 
                        if($file != '.' && $file != '..')
                                chmodRecursive($path.'/'.$file, $modeFile,$modeFolder,$userName,$groupName); 
                closedir($dh); 
        } 
        else
        if (!is_link($path))
                chmodBase($path,$modeFile,$userName,$groupName);
} 

//--------------------------

requireLibFile("inotify/InEvent.php");
requireLibFile("admin/etcfiles/EtcPasswd.php");
requireLibFile("admin/etcfiles/EtcGroup.php");
requireLibFile("admin/etcfiles/EtcFsTab.php");
requireLibFile("admin/sysqueries/df.php");
requireLibFile("admin/action-engine/Incrontab.php");
requireLibFile("inotify/syslog.php");
requireLibFile("inotify/SharingStructureDefault.php");
requireLibFile("inotify/SharingStructureAvid.php");
requireLibFile("inotify/SharingStructureMXF.php");
requireLibFile("inotify/SharingOperations.php");
requireLibFile("inotify/SharingFolders.php");
requireLibFile("inotify/LockingMechanism.php");

syslog_notice_start_running();

//syslog error handling
function customError($errno,$errmsg,$errfile,$errline)
{
        if($errno==0) return true; //ignore errors prepended with @
	syslog_notice("err:$errno,$errmsg in file $errfile, line $errline");
	die();
}
set_error_handler("customError");

//catch fatal errors
function handleShutdown()
{
	$error = error_get_last();
	if($error !== NULL)
		customError('FATAL-SHUTDOWN',$error['message'],$error['file'],$error['line']);
}
register_shutdown_function('handleShutdown');

//prepare commandline args
$inEvent=new InEvent();

//only handle project folders or Avid MediaFiles folder
if($inEvent->watchType=='MAIN' && 
	!SharingFolders::isProjectFolder($inEvent->fsObject) &&
	$inEvent->fsObject!='Avid MediaFiles'
) terminate("folder concerned '{$inEvent->fsObject}' not a project folder");

//only handle .avp/.avs files
if($inEvent->watchType=='PRJ' && 
	!SharingFolders::endsWith($inEvent->fsObject,'.avp') &&
	!SharingFolders::endsWith($inEvent->fsObject,'.avs')
) terminate("avid file concerned '{$inEvent->fsObject}' not a .avp nor .avs file");

//find user for folder
$homeFolder=$inEvent->homeFolder();
$etcPasswd=EtcPasswd::instance();
$user=$etcPasswd->findUserByHomeFolder($homeFolder);
if($user==null) terminate("Cannot find user for home folder '$homeFolder'");
$userName=$user->name;

//find group for user
$etcGroup=EtcGroup::instance();
$group=$etcGroup->findGroupForUserName($userName);
if($group==null) terminate("Cannot find group for user '$userName'");
$groupName=$group->name;

//we know user and group now
syslog_notice("user is: '$userName' group is: '$groupName'");

//retrieve all group members
$members=$etcPasswd->findUsersForEtcGroup($group);

$lockingMechanism=new LockingMechanism($groupName);
$lockingMechanism->lock();
do
{
	if(($inEvent->watchType=='MAIN' && SharingFolders::isAvidProjectFolder($inEvent->fsObject)) ||
		$inEvent->watchType=='PRJ')
	{
		SharingStructureAvid::reshare($groupName,$members);
		SharingStructureMXF::reshare($members);
	}
        elseif($inEvent->watchType=='UNPROTECTED')
        {
                if(basename($inEvent->folderWatched)=='Unprotected') { $modeFolder=0775; $modeFile=0664; }
                else { $modeFolder=0755; $modeFile=0644; }
                chmodRecursive($inEvent->folderWatched, $modeFile,$modeFolder,$userName,'is_'.$groupName);
        }
	else
	{
		SharingStructureDefault::reshare($groupName,$members);
	}
	SharingStructureMXF::reshare($members);
}
while($lockingMechanism->mustReRun());
$lockingMechanism->unlock();

Incrontab::generate();

//notify end run
syslog_notice_end_running();

